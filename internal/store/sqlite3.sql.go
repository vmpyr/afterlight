// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sqlite3.sql

package store

import (
	"context"
	"database/sql"
	"time"

	"github.com/vmpyr/afterlight/internal/core"
)

const createArtifact = `-- name: CreateArtifact :one
INSERT INTO artifacts (id, vault_id, message_type, encrypted_blob, iv)
VALUES (?, ?, ?, ?, ?)
RETURNING id, vault_id, message_type, encrypted_blob, iv, created_at
`

type CreateArtifactParams struct {
	ID            string             `json:"id"`
	VaultID       string             `json:"vault_id"`
	MessageType   core.MessageType   `json:"message_type"`
	EncryptedBlob core.EncryptedBlob `json:"encrypted_blob"`
	Iv            string             `json:"iv"`
}

func (q *Queries) CreateArtifact(ctx context.Context, arg CreateArtifactParams) (Artifact, error) {
	row := q.queryRow(ctx, q.createArtifactStmt, createArtifact,
		arg.ID,
		arg.VaultID,
		arg.MessageType,
		arg.EncryptedBlob,
		arg.Iv,
	)
	var i Artifact
	err := row.Scan(
		&i.ID,
		&i.VaultID,
		&i.MessageType,
		&i.EncryptedBlob,
		&i.Iv,
		&i.CreatedAt,
	)
	return i, err
}

const createContactMethod = `-- name: CreateContactMethod :one
INSERT INTO contact_methods (
    id, user_id, beneficiary_id, channel, destination, metadata, created_at
) VALUES (
    ?, ?, ?, ?, ?, ?, ?
) RETURNING id, user_id, beneficiary_id, channel, destination, metadata, created_at
`

type CreateContactMethodParams struct {
	ID            string         `json:"id"`
	UserID        sql.NullString `json:"user_id"`
	BeneficiaryID sql.NullString `json:"beneficiary_id"`
	Channel       string         `json:"channel"`
	Destination   string         `json:"destination"`
	Metadata      core.Metadata  `json:"metadata"`
	CreatedAt     time.Time      `json:"created_at"`
}

func (q *Queries) CreateContactMethod(ctx context.Context, arg CreateContactMethodParams) (ContactMethod, error) {
	row := q.queryRow(ctx, q.createContactMethodStmt, createContactMethod,
		arg.ID,
		arg.UserID,
		arg.BeneficiaryID,
		arg.Channel,
		arg.Destination,
		arg.Metadata,
		arg.CreatedAt,
	)
	var i ContactMethod
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BeneficiaryID,
		&i.Channel,
		&i.Destination,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (token, user_id, expires_at)
VALUES (?, ?, ?)
RETURNING token, user_id, expires_at, created_at
`

type CreateSessionParams struct {
	Token     string    `json:"token"`
	UserID    string    `json:"user_id"`
	ExpiresAt time.Time `json:"expires_at"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.queryRow(ctx, q.createSessionStmt, createSession, arg.Token, arg.UserID, arg.ExpiresAt)
	var i Session
	err := row.Scan(
		&i.Token,
		&i.UserID,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    id, name, email, password_hash,
    is_paused, check_in_interval, trigger_interval_num, buffer_period, verifier_quorum,
    last_check_in, current_status
) VALUES (
    ?, ?, ?, ?,
    ?, ?, ?, ?, ?,
    ?, ?
) RETURNING id, name, email, password_hash, is_paused, check_in_interval, trigger_interval_num, buffer_period, verifier_quorum, last_check_in, current_status, created_at
`

type CreateUserParams struct {
	ID                 string          `json:"id"`
	Name               string          `json:"name"`
	Email              string          `json:"email"`
	PasswordHash       string          `json:"password_hash"`
	IsPaused           bool            `json:"is_paused"`
	CheckInInterval    int64           `json:"check_in_interval"`
	TriggerIntervalNum int64           `json:"trigger_interval_num"`
	BufferPeriod       int64           `json:"buffer_period"`
	VerifierQuorum     sql.NullInt64   `json:"verifier_quorum"`
	LastCheckIn        time.Time       `json:"last_check_in"`
	CurrentStatus      core.UserStatus `json:"current_status"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.queryRow(ctx, q.createUserStmt, createUser,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.PasswordHash,
		arg.IsPaused,
		arg.CheckInInterval,
		arg.TriggerIntervalNum,
		arg.BufferPeriod,
		arg.VerifierQuorum,
		arg.LastCheckIn,
		arg.CurrentStatus,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.IsPaused,
		&i.CheckInInterval,
		&i.TriggerIntervalNum,
		&i.BufferPeriod,
		&i.VerifierQuorum,
		&i.LastCheckIn,
		&i.CurrentStatus,
		&i.CreatedAt,
	)
	return i, err
}

const createVault = `-- name: CreateVault :one
INSERT INTO vaults (id, user_id, vault_name, hint, kdf_salt)
VALUES (?, ?, ?, ?, ?)
RETURNING id, user_id, vault_name, hint, kdf_salt, created_at
`

type CreateVaultParams struct {
	ID        string         `json:"id"`
	UserID    string         `json:"user_id"`
	VaultName string         `json:"vault_name"`
	Hint      sql.NullString `json:"hint"`
	KdfSalt   string         `json:"kdf_salt"`
}

func (q *Queries) CreateVault(ctx context.Context, arg CreateVaultParams) (Vault, error) {
	row := q.queryRow(ctx, q.createVaultStmt, createVault,
		arg.ID,
		arg.UserID,
		arg.VaultName,
		arg.Hint,
		arg.KdfSalt,
	)
	var i Vault
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.VaultName,
		&i.Hint,
		&i.KdfSalt,
		&i.CreatedAt,
	)
	return i, err
}

const createVaultAccess = `-- name: CreateVaultAccess :one
INSERT INTO vault_access (vault_id, beneficiary_id)
VALUES (?, ?)
RETURNING vault_id, beneficiary_id, granted_at
`

type CreateVaultAccessParams struct {
	VaultID       string `json:"vault_id"`
	BeneficiaryID string `json:"beneficiary_id"`
}

func (q *Queries) CreateVaultAccess(ctx context.Context, arg CreateVaultAccessParams) (VaultAccess, error) {
	row := q.queryRow(ctx, q.createVaultAccessStmt, createVaultAccess, arg.VaultID, arg.BeneficiaryID)
	var i VaultAccess
	err := row.Scan(&i.VaultID, &i.BeneficiaryID, &i.GrantedAt)
	return i, err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions WHERE token = ?
`

func (q *Queries) DeleteSession(ctx context.Context, token string) error {
	_, err := q.exec(ctx, q.deleteSessionStmt, deleteSession, token)
	return err
}

const getArtifactsByVault = `-- name: GetArtifactsByVault :many
SELECT a.id, a.vault_id, a.message_type, a.encrypted_blob, a.iv, a.created_at FROM artifacts a
JOIN vaults v ON a.vault_id = v.id
WHERE a.vault_id = ? AND v.user_id = ?
ORDER BY a.created_at DESC
`

type GetArtifactsByVaultParams struct {
	VaultID string `json:"vault_id"`
	UserID  string `json:"user_id"`
}

func (q *Queries) GetArtifactsByVault(ctx context.Context, arg GetArtifactsByVaultParams) ([]Artifact, error) {
	rows, err := q.query(ctx, q.getArtifactsByVaultStmt, getArtifactsByVault, arg.VaultID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Artifact
	for rows.Next() {
		var i Artifact
		if err := rows.Scan(
			&i.ID,
			&i.VaultID,
			&i.MessageType,
			&i.EncryptedBlob,
			&i.Iv,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, name, email, password_hash, is_paused, check_in_interval, trigger_interval_num, buffer_period, verifier_quorum, last_check_in, current_status, created_at FROM users
WHERE email = ? LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.queryRow(ctx, q.getUserByEmailStmt, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.IsPaused,
		&i.CheckInInterval,
		&i.TriggerIntervalNum,
		&i.BufferPeriod,
		&i.VerifierQuorum,
		&i.LastCheckIn,
		&i.CurrentStatus,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, name, email, password_hash, is_paused, check_in_interval, trigger_interval_num, buffer_period, verifier_quorum, last_check_in, current_status, created_at FROM users
WHERE id = ? LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id string) (User, error) {
	row := q.queryRow(ctx, q.getUserByIDStmt, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.IsPaused,
		&i.CheckInInterval,
		&i.TriggerIntervalNum,
		&i.BufferPeriod,
		&i.VerifierQuorum,
		&i.LastCheckIn,
		&i.CurrentStatus,
		&i.CreatedAt,
	)
	return i, err
}

const getUserBySessionToken = `-- name: GetUserBySessionToken :one
SELECT u.id, u.name, u.email, u.password_hash, u.is_paused, u.check_in_interval, u.trigger_interval_num, u.buffer_period, u.verifier_quorum, u.last_check_in, u.current_status, u.created_at FROM sessions s
JOIN users u ON s.user_id = u.id
WHERE s.token = ? AND s.expires_at > CURRENT_TIMESTAMP
`

func (q *Queries) GetUserBySessionToken(ctx context.Context, token string) (User, error) {
	row := q.queryRow(ctx, q.getUserBySessionTokenStmt, getUserBySessionToken, token)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.IsPaused,
		&i.CheckInInterval,
		&i.TriggerIntervalNum,
		&i.BufferPeriod,
		&i.VerifierQuorum,
		&i.LastCheckIn,
		&i.CurrentStatus,
		&i.CreatedAt,
	)
	return i, err
}

const getVaultByID = `-- name: GetVaultByID :one
SELECT id, user_id, vault_name, hint, kdf_salt, created_at FROM vaults
WHERE id = ? AND user_id = ?
`

type GetVaultByIDParams struct {
	ID     string `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) GetVaultByID(ctx context.Context, arg GetVaultByIDParams) (Vault, error) {
	row := q.queryRow(ctx, q.getVaultByIDStmt, getVaultByID, arg.ID, arg.UserID)
	var i Vault
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.VaultName,
		&i.Hint,
		&i.KdfSalt,
		&i.CreatedAt,
	)
	return i, err
}

const getVaultsByUser = `-- name: GetVaultsByUser :many
SELECT id, user_id, vault_name, hint, kdf_salt, created_at FROM vaults
WHERE user_id = ?
ORDER BY created_at DESC
`

func (q *Queries) GetVaultsByUser(ctx context.Context, userID string) ([]Vault, error) {
	rows, err := q.query(ctx, q.getVaultsByUserStmt, getVaultsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vault
	for rows.Next() {
		var i Vault
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.VaultName,
			&i.Hint,
			&i.KdfSalt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContactMethodsByUserID = `-- name: ListContactMethodsByUserID :many
SELECT id, user_id, beneficiary_id, channel, destination, metadata, created_at FROM contact_methods
WHERE user_id = ?
`

func (q *Queries) ListContactMethodsByUserID(ctx context.Context, userID sql.NullString) ([]ContactMethod, error) {
	rows, err := q.query(ctx, q.listContactMethodsByUserIDStmt, listContactMethodsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ContactMethod
	for rows.Next() {
		var i ContactMethod
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BeneficiaryID,
			&i.Channel,
			&i.Destination,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserCheckIn = `-- name: UpdateUserCheckIn :exec
UPDATE users
SET last_check_in = ?, current_status = 'ALIVE'
WHERE id = ?
`

type UpdateUserCheckInParams struct {
	LastCheckIn time.Time `json:"last_check_in"`
	ID          string    `json:"id"`
}

func (q *Queries) UpdateUserCheckIn(ctx context.Context, arg UpdateUserCheckInParams) error {
	_, err := q.exec(ctx, q.updateUserCheckInStmt, updateUserCheckIn, arg.LastCheckIn, arg.ID)
	return err
}
