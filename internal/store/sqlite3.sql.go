// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sqlite3.sql

package store

import (
	"context"
	"database/sql"
	"time"

	"github.com/vmpyr/afterlight/internal/core"
)

const createContactMethod = `-- name: CreateContactMethod :one
INSERT INTO contact_methods (
    id, user_id, beneficiary_id, channel, target, metadata, created_at
) VALUES (
    ?, ?, ?, ?, ?, ?, ?
) RETURNING id, user_id, beneficiary_id, channel, target, metadata, created_at
`

type CreateContactMethodParams struct {
	ID            string         `json:"id"`
	UserID        sql.NullString `json:"user_id"`
	BeneficiaryID sql.NullString `json:"beneficiary_id"`
	Channel       string         `json:"channel"`
	Target        string         `json:"target"`
	Metadata      core.Metadata  `json:"metadata"`
	CreatedAt     time.Time      `json:"created_at"`
}

func (q *Queries) CreateContactMethod(ctx context.Context, arg CreateContactMethodParams) (ContactMethod, error) {
	row := q.queryRow(ctx, q.createContactMethodStmt, createContactMethod,
		arg.ID,
		arg.UserID,
		arg.BeneficiaryID,
		arg.Channel,
		arg.Target,
		arg.Metadata,
		arg.CreatedAt,
	)
	var i ContactMethod
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BeneficiaryID,
		&i.Channel,
		&i.Target,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (token, user_id, expires_at)
VALUES (?, ?, ?)
RETURNING token, user_id, expires_at, created_at
`

type CreateSessionParams struct {
	Token     string    `json:"token"`
	UserID    string    `json:"user_id"`
	ExpiresAt time.Time `json:"expires_at"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.queryRow(ctx, q.createSessionStmt, createSession, arg.Token, arg.UserID, arg.ExpiresAt)
	var i Session
	err := row.Scan(
		&i.Token,
		&i.UserID,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    id, name, email, password_hash,
    is_paused, check_in_interval, trigger_interval_num, buffer_period, verifier_quorum,
    last_check_in, current_status
) VALUES (
    ?, ?, ?, ?,
    ?, ?, ?, ?, ?,
    ?, ?
) RETURNING id, name, email, password_hash, is_paused, check_in_interval, trigger_interval_num, buffer_period, verifier_quorum, last_check_in, current_status, created_at
`

type CreateUserParams struct {
	ID                 string          `json:"id"`
	Name               string          `json:"name"`
	Email              string          `json:"email"`
	PasswordHash       string          `json:"password_hash"`
	IsPaused           bool            `json:"is_paused"`
	CheckInInterval    int64           `json:"check_in_interval"`
	TriggerIntervalNum int64           `json:"trigger_interval_num"`
	BufferPeriod       int64           `json:"buffer_period"`
	VerifierQuorum     sql.NullInt64   `json:"verifier_quorum"`
	LastCheckIn        time.Time       `json:"last_check_in"`
	CurrentStatus      core.UserStatus `json:"current_status"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.queryRow(ctx, q.createUserStmt, createUser,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.PasswordHash,
		arg.IsPaused,
		arg.CheckInInterval,
		arg.TriggerIntervalNum,
		arg.BufferPeriod,
		arg.VerifierQuorum,
		arg.LastCheckIn,
		arg.CurrentStatus,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.IsPaused,
		&i.CheckInInterval,
		&i.TriggerIntervalNum,
		&i.BufferPeriod,
		&i.VerifierQuorum,
		&i.LastCheckIn,
		&i.CurrentStatus,
		&i.CreatedAt,
	)
	return i, err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions WHERE token = ?
`

func (q *Queries) DeleteSession(ctx context.Context, token string) error {
	_, err := q.exec(ctx, q.deleteSessionStmt, deleteSession, token)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, name, email, password_hash, is_paused, check_in_interval, trigger_interval_num, buffer_period, verifier_quorum, last_check_in, current_status, created_at FROM users
WHERE email = ? LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.queryRow(ctx, q.getUserByEmailStmt, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.IsPaused,
		&i.CheckInInterval,
		&i.TriggerIntervalNum,
		&i.BufferPeriod,
		&i.VerifierQuorum,
		&i.LastCheckIn,
		&i.CurrentStatus,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, name, email, password_hash, is_paused, check_in_interval, trigger_interval_num, buffer_period, verifier_quorum, last_check_in, current_status, created_at FROM users
WHERE id = ? LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id string) (User, error) {
	row := q.queryRow(ctx, q.getUserByIDStmt, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.IsPaused,
		&i.CheckInInterval,
		&i.TriggerIntervalNum,
		&i.BufferPeriod,
		&i.VerifierQuorum,
		&i.LastCheckIn,
		&i.CurrentStatus,
		&i.CreatedAt,
	)
	return i, err
}

const getUserBySessionToken = `-- name: GetUserBySessionToken :one
SELECT u.id, u.name, u.email, u.password_hash, u.is_paused, u.check_in_interval, u.trigger_interval_num, u.buffer_period, u.verifier_quorum, u.last_check_in, u.current_status, u.created_at FROM sessions s
JOIN users u ON s.user_id = u.id
WHERE s.token = ? AND s.expires_at > CURRENT_TIMESTAMP
`

func (q *Queries) GetUserBySessionToken(ctx context.Context, token string) (User, error) {
	row := q.queryRow(ctx, q.getUserBySessionTokenStmt, getUserBySessionToken, token)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.IsPaused,
		&i.CheckInInterval,
		&i.TriggerIntervalNum,
		&i.BufferPeriod,
		&i.VerifierQuorum,
		&i.LastCheckIn,
		&i.CurrentStatus,
		&i.CreatedAt,
	)
	return i, err
}

const listContactMethodsByUserID = `-- name: ListContactMethodsByUserID :many
SELECT id, user_id, beneficiary_id, channel, target, metadata, created_at FROM contact_methods
WHERE user_id = ?
`

func (q *Queries) ListContactMethodsByUserID(ctx context.Context, userID sql.NullString) ([]ContactMethod, error) {
	rows, err := q.query(ctx, q.listContactMethodsByUserIDStmt, listContactMethodsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ContactMethod
	for rows.Next() {
		var i ContactMethod
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BeneficiaryID,
			&i.Channel,
			&i.Target,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserCheckIn = `-- name: UpdateUserCheckIn :exec
UPDATE users
SET last_check_in = ?, current_status = 'ALIVE'
WHERE id = ?
`

type UpdateUserCheckInParams struct {
	LastCheckIn time.Time `json:"last_check_in"`
	ID          string    `json:"id"`
}

func (q *Queries) UpdateUserCheckIn(ctx context.Context, arg UpdateUserCheckInParams) error {
	_, err := q.exec(ctx, q.updateUserCheckInStmt, updateUserCheckIn, arg.LastCheckIn, arg.ID)
	return err
}
